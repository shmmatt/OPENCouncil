Yep — I can see *exactly* why your agent keeps looping: it’s chasing the wrong “identifier” coming back from Gemini, and your UI is probably rendering the wrong field even when the server finds the right record.

Also: you pasted a real admin password + JWT in that trace. **Rotate both immediately** (change password + invalidate/rotate JWT signing secret / sessions). Don’t rely on “it’s just local logs” — it ends up copied around.

## What’s actually happening

### 1) Gemini is returning **a doc “title” that is not a title**

Your agent observed Gemini grounding metadata like:

* `retrievedContext.title: "07fc64d94cda428a2db1073b7b5dd35c"` (hex)

That’s not a human title; it’s an **internal document ID / hash** (or a “chunk title” field being populated with the doc id depending on the API response format).

So any approach like:

* “match by displayName”
* “store geminiDisplayName”
  won’t work *if the grounding payload never returns that displayName.*

### 2) You *did* the right move by adding `gemini_internal_id` — but you’re likely extracting the wrong key

You backfilled `document_versions.gemini_internal_id` successfully (135/135), which means **you have enough information to map citations**.

But your extraction function (`extractSourceDocumentNames()` or equivalent in `server/chatV2/simpleAnswer.ts`) is probably doing one of these mistakes:

* Using `retrievedContext.title` as the ID (hex) ✅ but then **looking it up as fileSearchDocumentName or displayName** ❌
* Or only extracting the *hex* but your DB stored the *full resource name* or vice versa (e.g., stored `documents/78bda...` while extracted only `78bda...`)
* Or: you *are* mapping correctly on the server, but the **client is displaying `source.id` instead of `source.displayName/title`**

### 3) The “sources bubble” and “inline citations” are two different pipelines

You already noticed:

* Inline citations in the generated answer can look “nice” (LLM wrote them)
* The Sources bubble is built from your grounding metadata → your mapping code → UI rendering

So you must fix **(a) extraction**, **(b) lookup**, and **(c) UI label selection**.

---

## The fix that will stop the thrash (do this in order)

### Step A — Make extraction deterministic (server)

In `server/chatV2/simpleAnswer.ts` (or wherever you parse Gemini grounding), capture *all three* of these from each grounded chunk:

1. `retrievedContext.uri` (often a full resource path)
2. `retrievedContext.title` (currently hex)
3. any `retrievedContext` “name/id” field if present

Then normalize to a single `geminiDocId`:

* If `uri` contains `/documents/`, extract the substring after `/documents/`
* Else if `title` looks like a hex id, use `title`
* Else fallback: keep raw and log

You want your “citation key” to be **the Gemini doc id** you’re now storing in `document_versions.gemini_internal_id`.

### Step B — Lookup priority (server/storage.ts)

In your `getDocumentVersionForCitation()` lookup (whatever you named it), do:

1. **gemini_internal_id match**
2. fileSearchDocumentName match (full resource)
3. geminiDisplayName match (only helpful if you ever get it)
4. last resort: canonicalTitle match

Return a stable object like:

```ts
{
  id: documentVersionId,
  label: documentVersions.geminiDisplayName ?? logicalDocuments.canonicalTitle ?? fileBlobs.originalFilename ?? geminiDocId,
  viewerUrl: ...,
}
```

### Step C — Client must render `label`, never `id`

Your UI bug smells like: the server may already be returning both `id` and `label`, but the client is rendering `source.id` in the Sources bubble.

In `client/src/pages/chat.tsx`, ensure the Sources bubble does:

* display text: `source.label` (or `source.title`)
* href: whatever the correct viewer route is
* keep the hash only as a hidden debug field

---

## Replit Agent prompt that will actually land this

Paste this as-is:

> **Fix Sources bubble showing cryptic hashes.**
>
> 1. **Server extraction:** In `server/chatV2/simpleAnswer.ts` (or wherever Gemini groundingMetadata is parsed), update the citation extraction to derive a `geminiDocId` using this priority:
>
>    * If retrievedContext.uri contains `/documents/`, extract the id after `/documents/`
>    * Else if retrievedContext.title matches `/^[0-9a-f]{16,64}$/i/`, treat it as the doc id
>    * Else keep raw and log.
>      Add debug logs for one request showing: `title`, `uri`, `geminiDocId`.
>
> 2. **Storage lookup:** In `server/storage.ts`, implement/adjust `getDocumentVersionByCitationKey()` that first matches `document_versions.gemini_internal_id = geminiDocId`. If not found, fallback to match by `file_search_document_name` and then `gemini_display_name`.
>
> 3. **API response shape:** Ensure chat response sources include `{ docVersionId, label, href }` where `label` is a human-readable string (prefer `gemini_display_name`, else `logical_documents.canonical_title`, else `file_blobs.original_filename`, else `geminiDocId`).
>
> 4. **Client rendering:** In `client/src/pages/chat.tsx` (Sources bubble), render `source.label` as the link text (not id/hash), and link to `source.href`.
>
> 5. Add one integration test or a simple dev-only assertion: if `label` looks like a hex id, warn in console with the source object.
>
> Do not change the document ingestion system or create new tables. Use existing `gemini_internal_id` column.

---

## Quick “why did the backfill succeed but UI still shows hashes?”

Because backfill populates `gemini_internal_id`, but **either**:

* your runtime extraction is still using the wrong field (so the lookup never hits), **or**
* lookup succeeds but your UI displays the wrong property (id vs label)

You’ll know which one in 2 minutes by logging right after mapping sources:

* Log: `{ extractedGeminiDocId, matchedDocumentVersionId, label }`

If `matchedDocumentVersionId` is present but UI shows hash → it’s client rendering.
If it’s missing → it’s extraction/lookup mismatch.

---

If you paste **one real groundingMetadata snippet** (just the part with `groundingChunks/retrievedContext` for one source), I’ll tell you exactly which field you should parse in your case (`uri` vs `name` vs `title`) and the exact regex/substring.
